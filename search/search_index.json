{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JupyterLab DataMount Extension","text":""},{"location":"#overview","title":"Overview","text":"<p>The JupyterLab DataMount extension is designed to provide seamless access to external storage services directly within JupyterLab. By integrating multiple storage backends, it allows users to mount and interact with remote data effortlessly. The extension is especially useful for researchers and data analysts who need quick and secure access to large datasets.</p>"},{"location":"#why-use-jupyterlab-datamount","title":"Why Use JupyterLab DataMount?","text":"<ul> <li>Easy Storage Integration: Supports various storage backends, including WebDav, AWS, S3-compatible storage and many more.</li> <li>User-Friendly Interface: Provides a simple UI for managing data mounts without requiring complex configurations.</li> <li>Seamless JupyterHub Integration: Works effortlessly with JupyterHub, allowing admins to preconfigure storage access.</li> <li>Secure &amp; Efficient: Ensures data security with a sidecar-based approach and restricts privilege escalation.</li> <li>Flexible Usage: Works for different user needs, including read-only access, temporary mounts, and persistent storage.</li> </ul>"},{"location":"#who-should-use-this-extension","title":"Who Should Use This Extension?","text":"<p>JupyterLab DataMount is designed for:</p> <ul> <li>Researchers and Data Scientists who need to work with large datasets stored in remote locations.</li> <li>Educators and Students who require seamless access to educational resources and cloud storage.</li> <li>JupyterHub Administrators who want to preconfigure storage access for users while maintaining security.</li> </ul>"},{"location":"#security-features","title":"Security Features","text":"<p>JupyterLab DataMount is built with security in mind:</p> <ul> <li>Mounting realized in a sidecar container: The mounting process is embedded in a separate container, ensuring that the main JupyterLab environment remains isolated.</li> <li>No Privileged Execution: The extension operates without requiring root privileges, preventing unauthorized access.</li> <li>No Privilege Escalation: The security model explicitly disallows privilege escalation to ensure a controlled execution environment.</li> <li>Hidden Secrets: Storage credentials and secrets can be preconfigured and hidden from users while still allowing access to external storage in a controlled manner.</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>JupyterLab DataMount is ideal for:</p> <ul> <li>Data Science &amp; Research: Access remote datasets for analysis and visualization without downloading them manually.</li> <li>Cloud-Based Workflows: Mount cloud storage solutions (AWS S3, WebDav, B2Drop, etc.) to work on data stored remotely.</li> <li>Collaborative Environments: Enable teams to access shared storage locations securely within JupyterLab.</li> <li>Read-Only Data Access: Provide users with access to preconfigured datasets without exposing credentials or write permissions.</li> </ul> <p>This extension enhances productivity by simplifying how data is accessed and managed within JupyterLab, while maintaining strong security practices.</p> <p>For detailed documentation, refer to the specific sections on Installation, Using the Extension and Security Details.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to expand the available mount templates. You can find existing templates in the source code repository, which can serve as blueprints for creating new ones.</p> <ul> <li>Existing Templates: GitHub</li> <li>How to contribute:</li> <li>Create your own mount template based on existing ones.</li> <li>Test it to ensure it works as expected. Development</li> <li>Submit a Pull Request to the repository.</li> </ul> <p>We appreciate community contributions to enhance the software!</p>"},{"location":"architecture/backend_api/","title":"Backend REST API","text":""},{"location":"architecture/backend_api/#overview","title":"Overview","text":"<p>The REST API (GitHub source) is responsible for handling mount operations by executing <code>rclone</code> commands based on incoming requests. It supports POST, GET, and DELETE methods, making it a flexible solution capable of leveraging most of <code>rclone</code>'s features.</p>"},{"location":"architecture/backend_api/#supported-methods","title":"Supported Methods","text":""},{"location":"architecture/backend_api/#post","title":"<code>POST /</code>","text":"<p>Mounts external storage based on the provided configuration.</p> <p>Request Body Example:</p> <pre><code>{\n  \"path\": \"relative_path\",\n  \"options\": {\n    \"config\": {\n      # rclone configuration\n    },\n    \"readonly\": false,\n    \"template\": \"s3\"\n  }\n}\n</code></pre>"},{"location":"architecture/backend_api/#get","title":"<code>GET /</code>","text":"<p>Returns a list of currently active mounts.</p>"},{"location":"architecture/backend_api/#delete-pathpath","title":"<code>DELETE /{path:path}</code>","text":"<p>Unmounts a previously mounted storage location.</p>"},{"location":"architecture/backend_api/#flexibility-feature-set","title":"Flexibility &amp; Feature Set","text":"<p>Since the API directly executes <code>rclone</code> commands based on the provided parameters, it is highly flexible and supports nearly all features of <code>rclone</code>. Users can configure different storage providers, authentication methods, and transfer settings as needed.</p> <p>For more details and the full implementation, refer to the source code.</p>"},{"location":"architecture/overview/","title":"Architecture","text":""},{"location":"architecture/overview/#overview","title":"Overview","text":"<p>The JupyterLab DataMount Extension integrates external storage seamlessly into Jupyter environments using a sidecar container approach. Below is an overview of the architecture:</p> Architecture with additional information:"},{"location":"architecture/overview/#mount-propagation-security","title":"Mount Propagation &amp; Security","text":"<ul> <li>The rclone sidecar container requires mountPropagation: Bidirectional, which enables proper propagation of mounted storage.</li> <li>The Jupyter container only needs mountPropagation: HostToContainer, ensuring that it can access mounts without additional privileges.</li> <li>To support this mechanism:<ul> <li>The mount container runs as <code>root</code> with <code>privileged: true</code> to handle mounting securely.</li> <li>The Jupyter container operates as the <code>jovyan</code> user with no extra privileges, ensuring security by design.</li> </ul> </li> </ul> <p>This architecture ensures that administrators do not need to grant additional permissions to enable the JupyterLab DataMount Extension.</p>"},{"location":"architecture/overview/#compatibility-flexibility","title":"Compatibility &amp; Flexibility","text":"<p>The extension is designed to function in various environments, provided that:</p> <ol> <li>A REST API is available to handle mount requests.</li> <li>A shared volume exists between the Jupyter container and the REST API container to support mount propagation.</li> </ol>"},{"location":"architecture/overview/#kubernetes-zero2jupyterhub","title":"Kubernetes &amp; Zero2JupyterHub","text":"<p>While the extension is adaptable to different setups, it is optimized for use with the Zero2JupyterHub Helm Chart on Kubernetes, providing a streamlined and simple deployment process. Look into the Spawner section for more information.</p>"},{"location":"spawner/configuration/","title":"JupyterHub DataMount Spawner Configuration","text":""},{"location":"spawner/configuration/#overview","title":"Overview","text":"<p>This section provides a detailed explanation of the available configuration options for the JupyterHub DataMount Spawner.</p>"},{"location":"spawner/configuration/#configuration-features","title":"Configuration Features","text":""},{"location":"spawner/configuration/#templates","title":"Templates","text":"<pre><code>c.KubeSpawner.templates = [\"b2drop\", \"aws\", \"s3\", \"webdav\", \"generic\"]\n</code></pre> <ul> <li>Allows administrators to specify which mount templates should be visible to users.</li> <li>Users can only create mounts based on the listed templates, providing controlled access to external storage.</li> <li>List of currently supported templates can be seen here (class <code>MountDialogComponent</code> , attribute <code>templates_all</code>)</li> </ul>"},{"location":"spawner/configuration/#logging-configuration","title":"Logging Configuration","text":"<pre><code>c.KubeSpawner.logging_config = {\n  \"stream\": {\n    \"enabled\": True,\n    \"level\": 20,\n    \"formatter\": \"simple\",\n    \"stream\": \"ext://sys.stdout\",\n  },\n  \"file\": {\n      \"enabled\": True,\n      \"level\": 20,\n      \"filename\": \"/mnt/data_mounts/mount.log\",\n      \"formatter\": \"simple_user\", # simple_user, simple or json\n      \"when\": \"h\",\n      \"interval\": 1,\n      \"backupCount\": 0,\n      \"encoding\": None,\n      \"delay\": false,\n      \"utc\": false,\n      \"atTime\": None,\n      \"errors\": None,\n  },\n  \"syslog\": {\n    \"enabled\": False,\n    \"level\": 20,\n    \"formatter\": \"json\",\n    \"address\": [\"ip\", 5141],\n    \"facility\": 1,\n    \"socktype\": \"ext://socket.SOCK_DGRAM\",\n  },\n  \"smtp\": {\n    \"enabled\": False,\n    \"level\": 50,\n    \"formatter\": \"simple\",\n    \"mailhost\": \"mailhost\",\n    \"fromaddr\": \"smtpmail\",\n    \"toaddrs\": [],\n    \"subject\": \"SMTPHandler - Log\",\n    \"secure\": None,\n    \"timeout\": 1,\n  }\n}\n</code></pre> <ul> <li>Configures Python\u2019s logging handler to monitor the extension\u2019s usage.</li> <li>Supported logging handlers: <code>stream</code>, <code>file</code>, <code>syslog</code>, <code>smtp</code>. <code>stream</code> and <code>file</code> are enabled by default.</li> <li>The log format and verbosity level can be customized as needed.</li> </ul> <p>The <code>file</code> LogHandler is used as feedback for the user. Keep that in mind when editing its configuration.</p>"},{"location":"spawner/configuration/#init-mounts","title":"Init Mounts","text":"<pre><code>c.KubeSpawner.init_mounts = [\n  {\n    \"path\": \"aws_pre\",\n    \"options\": {\n      \"displayName\": \"AWS (external)\",\n      \"template\": \"aws\",\n      \"config\": {\n        \"remotepath\": \"myawsbucket\",\n        \"type\": \"s3\",\n        \"provider\": \"AWS\",\n        \"access_key_id\": \"&lt;ACCESS_KEY&gt;\",\n        \"secret_access_key\": \"&lt;SECRET_KEY&gt;\",\n        \"region\": \"eu-north-1\"\n      }\n    }\n  }\n]\n</code></pre> <ul> <li>Enables automatic mounting of external storage when JupyterLab starts.</li> <li>Mounted storage is available to the user without manual intervention.</li> <li>Secrets (e.g., credentials) remain hidden from the user, ensuring security.</li> </ul> <p>By leveraging these configuration options, administrators can fine-tune the JupyterHub DataMount Spawner for their specific deployment needs.</p>"},{"location":"spawner/configuration/#remember-mounts","title":"Remember Mounts","text":"<p>To allow users to remember mounts that persist after JupyterLab restarts, each user must have a user-specific persistent storage. Their mount configurations will be stored in plain text at a place that an administrator has to configure. It must be configured via <code>KubeSpawner.data_mount_config</code>.</p> <pre><code>c.KubeSpawner.data_mount_config = \"\"\"\nc.DataMount.remember_enabled = True # default is False\nc.DataMount.remember_file = \"/home/jovyan/.jupyter/datamounts/mounts.json\" # update if your persistent storage is at $HOME/work\nc.DataMount.remember_default = False # configure whether the checkbox should be enabled by default. Default: False\n\"\"\"\n</code></pre>"},{"location":"spawner/configuration/#enable-nfs","title":"Enable NFS","text":"<p>By default NFS is disabled, since there's no authentication in plain NFS setups.</p> <pre><code>c.KubeSpawner.enable_nfs_mounts = True # default is false\nc.KubeSpawner.blocked_nfs_mounts = [\"192.168.0.0/24\"] # User's won't be able to mount any Server within that CIDR. Can be an empty list, or multiple CIDR strings in a list.\n</code></pre>"},{"location":"spawner/installation/","title":"JupyterHub DataMount Spawner Installation","text":""},{"location":"spawner/installation/#overview","title":"Overview","text":"<p>The JupyterHub DataMount Spawner (GitHub source) is designed for seamless integration within Zero2JupyterHub (Z2JH) deployments. It extends JupyterHub\u2019s Spawner functionality, enabling automatic mounting of external storage resources through the DataMount extension.</p>"},{"location":"spawner/installation/#installation","title":"Installation","text":"<p>To use the DataMount Spawner within a Z2JH setup, the only required configuration is:</p> <pre><code>hub:\n  args:\n    - -c\n    - &gt;-\n      pip install jupyterhub-datamountspawner &amp;&amp;\n      jupyterhub -f /usr/local/etc/jupyterhub/jupyterhub_config.py\n  command:\n    - /bin/bash\n  extraConfig:\n    customConfig: |\n      c.JupyterHub.spawner_class = 'datamountspawner.KubeSpawner'\n</code></pre>"},{"location":"spawner/installation/#compatibility-with-z2jh","title":"Compatibility with Z2JH","text":"<p>You can still use any other Spawner-specific Zero2JupyterHub configurations alongside the DataMount Spawner. For example:</p> <pre><code>singleuser:\n  image:\n    name: jupyter/minimal-notebook\n    tag: latest\n  storage:\n    type: none\n</code></pre> <p>This ensures full compatibility while leveraging the automatic mounting capabilities provided by the DataMount Spawner.</p>"},{"location":"users/howto/","title":"Using JupyterLab DataMount","text":""},{"location":"users/howto/#overview","title":"Overview","text":"<p>JupyterLab DataMount provides an intuitive way to access external storage within your JupyterLab environment. This guide walks you through using the extension, from opening the interface to mounting and managing your storage.</p>"},{"location":"users/howto/#accessing-the-extension","title":"Accessing the Extension","text":"<ol> <li>Open JupyterLab in your browser.</li> <li>Locate the DataMount sidebar on the left panel.</li> <li>Click on \"Add Mount\" to open the mount dialog.</li> </ol>"},{"location":"users/howto/#mounting-a-storage-location","title":"Mounting a Storage Location","text":"<ol> <li>Choose a Template    Select from predefined storage templates such as B2Drop, AWS S3, S3-compatible storage, WebDav, or a generic configuration.</li> <li>Specify the Mount Path    Define where the storage should be mounted within your JupyterLab environment.</li> <li>Enter Storage Credentials    Provide the necessary details (e.g. bucket name, API keys, tokens, or access credentials).</li> <li>Click Mount    The extension will establish a connection and mount the storage location.</li> </ol>"},{"location":"users/howto/#managing-mounted-storage","title":"Managing Mounted Storage","text":"<ul> <li>Open Directory: Open directory of mounted storage.</li> <li>Show settings: Show settings used during the mount process.</li> <li>Unmount: Unmount external storage location.</li> </ul>"},{"location":"users/howto/#working-with-mounted-storage","title":"Working with Mounted Storage","text":"<ul> <li>Access Files: Mounted storage will appear in the JupyterLab file browser, allowing you to open, edit, and manage files as if they were local.</li> <li>Read-Only vs Read-Write: Some mounts may be read-only, depending on the configuration.</li> <li>Performance Considerations: Remote storage access speed depends on network conditions and storage provider.</li> </ul>"},{"location":"users/howto/#remembering-mounts","title":"Remembering Mounts","text":"<p>If activated by the administrator, you can remember mount configurations that persist across JupyterLab restarts. When adding a new mount, enable \u201cRemember this mount\u201d to save its settings. The next time you open JupyterLab, they will be mounted during startup.</p> <p>This feature is especially useful if you frequently connect to the same external storage (e.g., B2DROP, S3, or institutional services).</p> <p>Your credentials will be stored in plain text in <code>$JUPYTERLAB_DATA_MOUNT_REMEMBER_FILE</code>.</p>"},{"location":"users/howto/#preconfigured-mounts","title":"Preconfigured Mounts","text":"<p>Before starting the JupyterLab, one can preconfigure data mounts. These mounts are set up by administrators and cannot be modified by the user. The underlying configurations remain hidden, ensuring that sensitive credentials are not exposed. This feature allows users to access shared datasets securely for tasks such as data visualization, analysis, or workshops without requiring direct access to storage credentials. Preconfigured mounts are displayed in italic and only provide the \"Open Directory\" button.</p>"},{"location":"users/howto/#next-steps","title":"Next Steps","text":"<p>Now that you\u2019ve learned how to mount storage, explore the Storage Templates section for specific details on configuring B2Drop, AWS S3, WebDav, and other storage options.</p>"},{"location":"users/issues/","title":"Troubleshooting","text":""},{"location":"users/issues/#checking-logs-for-issues","title":"Checking Logs for Issues","text":"<p>If you encounter any problems while mounting storage, you can check the logs of the mounting backend. The logs are written to:</p> <pre><code>/home/jovyan/data_mounts/mount.log\n</code></pre> <p>Reviewing this log file may provide insights into what went wrong and how to fix it.</p>"},{"location":"users/issues/#failed-unmount-resource-is-busy","title":"Failed Unmount: Resource is Busy","text":"<p>One common issue when unmounting a storage resource is receiving an error stating that the resource is busy. This happens when there are open files or processes still accessing the mounted directory.</p>"},{"location":"users/issues/#how-to-resolve","title":"How to resolve:","text":"<ol> <li>Ensure no files within the mount directory are open.</li> <li>Close any terminals or applications that may be using the mount.</li> <li>Retry unmounting the storage.</li> <li>If it still doesn't work don't worry. When the JupyterLab's stopped, everything will be unmounted.</li> </ol> <p>Due to the way JupyterLab operates, unmounting a storage mount may sometimes fail. For example, JupyterLab may attempt to create a <code>.ipynb-checkpoints</code> directory within a read-only mount, causing the system to keep the mount point \"busy.\" In such cases, the mount cannot be released until JupyterLab is stopped.</p>"},{"location":"users/templates/aws/","title":"AWS Template Configuration","text":"<p>The AWS template allows users to mount their Amazon Web Service S3 Bucket within JupyterLab.</p> <p>JupyterLab DataMount uses rclone to mount AWS. Check out their documentation for more details.</p>"},{"location":"users/templates/aws/#requirements","title":"Requirements","text":"<ul> <li>An Amazon S3 Storage Object. The setup process is not covered in this documentation, you can learn more about it here.</li> </ul>"},{"location":"users/templates/aws/#configuration-parameters","title":"Configuration Parameters","text":"<p>To configure an AWS mount, the following parameters are required:</p> <ul> <li>Bucket Name: AWS Bucket Name (myawsbucket4545 in the example above).</li> <li>Region: Region to connect to (eu-north-1 in the example above).</li> <li>Username: AWS Access Key ID.</li> <li>Password: AWS Secret Access Key.</li> </ul>"},{"location":"users/templates/aws/#advanced","title":"Advanced","text":"RClone configuration    The following configuration is used to mount AWS with rclone:   aws.config: <pre><code>[aws]\ntype = s3\nprovider = AWS\naccess_key_id = _username_\nsecret_access_key = _password_\nregion = _region_\n&lt;br&gt;\nMounted via &lt;br&gt;\n```bash\nrclone mount --config aws.config aws:_bucketname_ _path_ --vfs-cache-max-size=10G --vfs-read-chunk-size=64M --vfs-cache-mode=writes --allow-other --uid=1000 --gid=100\n</code></pre> JupyterHub pre_configuration    The following configuration can be used to preconfigure a AWS mount for users: <pre><code># pip install jupyterhub-datamountspawner\nc.JupyterHub.spawner_class = 'datamountspawner.KubeSpawner'\nc.KubeSpawner.init_mounts = [\n  {\n    \"path\": \"_path_\", # relative path. \"aws\" is a valid value\n    \"options\": {\n      \"displayName\": \"AWS (external)\",\n      \"template\": \"aws\",\n      \"readonly\": True, # default: False\n      \"config\": {\n        \"remotepath\": \"_bucketname_\",\n        \"type\": \"s3\",\n        \"provider\": \"AWS\",\n        \"access_key_id\": \"_id_\",\n        \"secret_access_key\": \"_secret_\",\n        \"region\": \"_region_\"\n      }\n    }\n  }\n]\n</code></pre>   - Replace _path_, _bucketname_, _region_, _id_ and _secret_   - Users will not see the used configuration"},{"location":"users/templates/b2drop/","title":"B2Drop Template Configuration","text":"<p>The B2Drop template allows users to mount their B2Drop storage within JupyterLab using WebDAV authentication.</p> <p>JupyterLab DataMount uses rclone to mount B2Drop. Check out their documentation for more details.</p>"},{"location":"users/templates/b2drop/#requirements","title":"Requirements","text":"<p>For a safe mount of B2Drop an app password is required.</p> <ol> <li>Open B2Drop Security Settings</li> <li>Scroll down, enter \"JupyterLab DataMount\" as \"App name\" and click on \"Create new app password\"</li> <li>Save \"Login\" ( aka user ) and \"Password\"</li> </ol> <p>Clicking on \"Create new app password\" does not do anything? Try using a different browser.</p>"},{"location":"users/templates/b2drop/#configuration-parameters","title":"Configuration Parameters","text":"<p>To configure a B2Drop mount, the following parameters are required:</p> <ul> <li>Path: The path within B2Drop to be mounted (default: <code>/</code>, mounts all files in B2Drop).</li> <li>User: \"Login\" from the app password.</li> <li>Password: \"Password\" from the app password.</li> </ul>"},{"location":"users/templates/b2drop/#advanced","title":"Advanced","text":"RClone configuration    The following configuration is used to mount B2Drop with rclone:   b2drop.config: <pre><code>[b2drop]\ntype = webdav\nurl = https://b2drop.eudat.eu/remote.php/dav/files/_user_/\nvendor = nextcloud\nuser = _user_\npass = _obscuredpassword_\n</code></pre>    Mounted via  <pre><code>rclone mount --config b2drop.config b2drop:_remotepath_ _path_ --vfs-cache-max-size=10G --vfs-read-chunk-size=64M --vfs-cache-mode=writes --allow-other --uid=1000 --gid=100\n</code></pre> JupyterHub pre_configuration    The following configuration can be used to preconfigure a B2Drop mount for users: <pre><code># pip install jupyterhub-datamountspawner\nc.JupyterHub.spawner_class = 'datamountspawner.KubeSpawner'\nc.KubeSpawner.init_mounts = [\n  {\n    \"path\": \"_path_\", # relative path. \"b2drop\" is a valid value\n    \"options\": {\n      \"displayName\": \"B2Drop (external)\",\n      \"template\": \"b2drop\",\n      \"readonly\": True, # default: False\n      \"config\": {\n        \"remotepath\": \"/\", # If only a subdirectory should be shared, define it here\n        \"type\": \"webdav\",\n        \"url\": \"https://b2drop.eudat.eu/remote.php/dav/files/_user_/\",\n        \"vendor\": \"nextcloud\",\n        \"user\": \"_user_\",\n        \"obscure_pass\": \"_password_\" # will be obscured during config creation\n      }\n    }\n  }\n]\n</code></pre> <ul>Replace _path_, _user_ and _password_</ul> <ul>Users will not see the used configuration</ul>"},{"location":"users/templates/generic/","title":"Generic Template Configuration","text":"<p>The Generic template allows users to mount each rclone supported Storage within JupyterLab.</p> <p>JupyterLab DataMount uses rclone to mount WebDAV. Check out their documentation for more details.</p>"},{"location":"users/templates/generic/#configuration-parameters","title":"Configuration Parameters","text":"<p>To configure a Generic mount, the following parameters are required:</p> <ul> <li>Type: Type of storage to configure.</li> <li>Add more options. Check out the rclone documentation for all options.</li> </ul>"},{"location":"users/templates/generic/#advanced","title":"Advanced","text":"RClone configuration    The following configuration is used to mount WebDAV with rclone:   generic.config: <pre><code>[generic]\ntype = _type_\n&lt;br&gt;\nMounted via &lt;br&gt;\n```bash\nrclone mount --config generic.config _type_:/ _path_ --vfs-cache-max-size=10G --vfs-read-chunk-size=64M --vfs-cache-mode=writes --allow-other --uid=1000 --gid=100\n</code></pre>"},{"location":"users/templates/nfs/","title":"NFS Template Configuration","text":"<p>The NFS template allows users to mount NFS servers within JupyterLab.</p> <p>This feature is disabled by default. JupyterHub administrators must enable it via JupyterHub DataMount KubeSpawner.</p>"},{"location":"users/templates/nfs/#configuration-parameters","title":"Configuration Parameters","text":"<p>To configure a NFS mount, the following parameters are required:</p> <ul> <li>Server: IP Address of the NFS Server.</li> <li>Path: NFS Server path.</li> </ul>"},{"location":"users/templates/nfs/#restricted-nfs-servers","title":"Restricted NFS Servers","text":"<p>For security reasons, administrators can define IP ranges that cannot be mounted by users. This prevents accidental or unauthorized access to sensitive exports, such as other users' home directories or internal system mounts.</p> <p>If you try to mount a blocked server, the request will be denied, and you will see an error message in mounts.log logfile.</p>"},{"location":"users/templates/s3/","title":"S3 Compliant Template Configuration","text":"<p>The S3 Compliant template allows users to mount their S3 Compliant Storage within JupyterLab.</p> <p>JupyterLab DataMount uses rclone to mount S3. Check out their documentation for more details.</p>"},{"location":"users/templates/s3/#configuration-parameters","title":"Configuration Parameters","text":"<p>To configure a S3 Compliant mount, the following parameters are required:</p> <ul> <li>Provider: Checkout rclone documentation for more information.</li> <li>Bucket Name: S3 Name. Will be used in rclone with <code>remote:_bucketname_</code></li> <li>API Endpoint: S3 Endpoint API url.</li> <li>Region: Region to connect to (eu-north-1 in the example above).</li> <li>Username: AWS Access Key ID.</li> <li>Password: AWS Secret Access Key.</li> </ul>"},{"location":"users/templates/s3/#advanced","title":"Advanced","text":"RClone configuration    The following configuration is used to mount S3 Compliant storage with rclone:   s3.config: <pre><code>[s3]\ntype = s3\nprovider = _provider_\nendpoint = _endpoint_\naccess_key_id = _username_\nsecret_access_key = _password_\nregion = _region_\n&lt;br&gt;\nMounted via &lt;br&gt;\n```bash\nrclone mount --config s3.config s3:_bucketname_ _path_ --vfs-cache-max-size=10G --vfs-read-chunk-size=64M --vfs-cache-mode=writes --allow-other --uid=1000 --gid=100\n</code></pre>"},{"location":"users/templates/webdav/","title":"WebDAV Template Configuration","text":"<p>The WebDAV template allows users to mount their WebDAV Storage within JupyterLab.</p> <p>JupyterLab DataMount uses rclone to mount WebDAV. Check out their documentation for more details.</p>"},{"location":"users/templates/webdav/#configuration-parameters","title":"Configuration Parameters","text":"<p>To configure a WebDAV mount, the following parameters are required:</p> <ul> <li>URL: URL of http host to connect to.</li> <li>Vendor: Name of the WebDAV site/service/software you are using.</li> <li>User: User name.</li> <li>Password: Password.</li> <li>Bearer Token: Bearer token instead of user/pass (e.g. a Macaroon)</li> </ul>"},{"location":"users/templates/webdav/#advanced","title":"Advanced","text":"RClone configuration    The following configuration is used to mount WebDAV with rclone:   webdav.config: <pre><code>[webdav]\ntype = webdav\nurl = _url_\nvendor = _vendor_\nuser = _user_\npass = _password_ # will be obscured during config creation\nbearer_token = _bearer_token_ # optional\n&lt;br&gt;\nMounted via &lt;br&gt;\n```bash\nrclone mount --config webdav.config webdav:/ _path_ --vfs-cache-max-size=10G --vfs-read-chunk-size=64M --vfs-cache-mode=writes --allow-other --uid=1000 --gid=100\n</code></pre>"}]}